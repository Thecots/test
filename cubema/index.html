<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./style.css">
</head>

<body>
    <div class="c-compare" style="--value:50%;">
        <canvas id="canvas1" class="c-compare__left"></canvas>
        <canvas id="canvas2" class="c-compare__right"></canvas>
        <input type="range" class="c-rng c-compare__range" min="0" max="100" value="50" oninput="updateSlider(this.value)" />
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let visibleRatio = 50; // Valor inicial del slider (50%)
        let lastSliderValue = 50; // Almacena el último valor seleccionado por el usuario
        let isDragging = false; // Para el movimiento de la cámara
        let isRangeActive = false; // Indica si el usuario está usando el slider
        let previousMousePosition = { x: 0, y: 0 };
        let blockSlider = false;

        // Escenas para cada skybox
        const scene1 = new THREE.Scene();
        const scene2 = new THREE.Scene();

        // Renderers para cada canvas
        const canvas1 = document.getElementById('canvas1');
        const canvas2 = document.getElementById('canvas2');
        const renderer1 = new THREE.WebGLRenderer({ canvas: canvas1 });
        const renderer2 = new THREE.WebGLRenderer({ canvas: canvas2 });

        // Cámaras
        const camera1 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const camera2 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera1.position.set(0, 0, 0);
        camera2.position.set(0, 0, 0);

        // Cargar texturas 360
        const textureLoader = new THREE.TextureLoader();
        const texture1 = textureLoader.load('./day.jpg'); // Primera imagen
        const texture2 = textureLoader.load('./night.png'); // Segunda imagen

        // Crear geometrías de las esferas invertidas
        const geometry = new THREE.SphereGeometry(500, 60, 40);
        const material1 = new THREE.MeshBasicMaterial({ map: texture1, side: THREE.BackSide });
        const material2 = new THREE.MeshBasicMaterial({ map: texture2, side: THREE.BackSide });

        const sphere1 = new THREE.Mesh(geometry, material1); // Primer skybox
        const sphere2 = new THREE.Mesh(geometry, material2); // Segundo skybox
        scene1.add(sphere1);
        scene2.add(sphere2);

        // Control de movimiento de la cámara con el ratón
        window.addEventListener('mousedown', function(e) {
            // Verificamos si se está haciendo clic en el slider
            if (e.target.classList.contains('c-rng')) {
                isRangeActive = true; // Si se está interactuando con el slider, bloquear el movimiento
                expandSlider(); // Expandir el slider
            } else {
                isDragging = true; // Si se hace clic fuera del slider, activar el movimiento de la cámara
            }
        });

        window.addEventListener('mousemove', function(e) {
            if (isDragging && !isRangeActive) {
                const deltaMove = {
                    x: e.offsetX - previousMousePosition.x,
                    y: e.offsetY - previousMousePosition.y
                };

                const rotationSpeed = 0.005;
                sphere1.rotation.y += deltaMove.x * rotationSpeed;
                sphere2.rotation.y += deltaMove.x * rotationSpeed;

                sphere1.rotation.x += deltaMove.y * rotationSpeed;
                sphere2.rotation.x += deltaMove.y * rotationSpeed;
            }

            previousMousePosition = { x: e.offsetX, y: e.offsetY };
        });

        window.addEventListener('mouseup', function() {
            isDragging = false;
            if (isRangeActive) {
                isRangeActive = false;
                shrinkSlider(); // Reducir el slider cuando el usuario suelte
            }
        });

        // Asegurar que no haya interferencias con el slider al soltar el ratón fuera de la pantalla
        window.addEventListener('mouseleave', function() {
            isDragging = false;
            isRangeActive = false;
            shrinkSlider(); // Reducir el slider si el ratón se sale de la pantalla
        });

        // Animación para renderizar ambos canvases
        function animate() {
            requestAnimationFrame(animate);

            // Renderizar el primer skybox en el primer canvas
            renderer1.render(scene1, camera1);

            // Renderizar el segundo skybox en el segundo canvas
            renderer2.render(scene2, camera2);
        }

        animate();

        // Ajustar tamaño de los canvases al redimensionar la ventana
        window.addEventListener('resize', () => {
            updateRenderSizes();
        });

        // Función para actualizar el valor del slider y ajustar la visibilidad
        function updateSlider(value) {
            
            document.querySelector('.c-compare').style.setProperty('--value', `${value}%`);
            lastSliderValue = value; // Almacenar el valor seleccionado

            // También actualizamos la posición del slider
            const range = document.querySelector('.c-compare__range');
            range.style.left = `0px`;
/*             range.style.background = "red"; 
 */        }

        // Expande el slider al hacer clic en él
        function expandSlider() {
            const range = document.querySelector('.c-compare__range');
            range.classList.add('expanded');

            // Al expandir, poner el valor almacenado del slider
            range.value = lastSliderValue;
            updateSlider(lastSliderValue);
        }

        // Reduce el slider cuando el usuario deja de interactuar
        function shrinkSlider() {
            const range = document.querySelector('.c-compare__range');
            range.classList.remove('expanded');

            // Volver a la mitad visualmente, pero el valor sigue almacenado
            //updateSlider(50);
            range.style.left = `calc(${lastSliderValue}% - 0.5rem)`;
            range.value = 50;
            //document.querySelector('.c-compare').style.setProperty('--value', `${50}%`);
        }

        // Ajusta el tamaño de los renderers y cámaras basado en el tamaño de la ventana
        function updateRenderSizes() {
            const totalWidth = window.innerWidth;
            const totalHeight = window.innerHeight;

            renderer1.setSize(totalWidth, totalHeight);
            renderer2.setSize(totalWidth, totalHeight);

            camera1.aspect = totalWidth / totalHeight;
            camera1.updateProjectionMatrix();
            camera2.aspect = totalWidth / totalHeight;
            camera2.updateProjectionMatrix();
        }

        updateRenderSizes(); // Ajuste inicial del tamaño de los canvases
    </script>
</body>
</html>
